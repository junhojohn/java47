<!DOCTYPE html>
<meta charset="utf-8">
<style>
.axis path {
    display: none;
}

.axis line {
    stroke-opacity: 0.3;
    shape-rendering: crispEdges;
}
</style>

<body>
    <div id="charts">
		<svg width="800" height="500"></svg>
	</div>
   <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        var parseDate = d3.timeFormat("%b-%Y");<!--y축 날짜데이터 포맷 정보-->
        var mainDiv = "#charts"; <!--div id가 charts인 영역 -->
        var mainDivName = "charts"; <!-- 순수 div id -->
		var group = ["Laptops", "Processor", "Ram"]; <!--차트에 표현할 데이터 종류-->
        var salesData = [{<!--실제 데이터-->
                'date': '2017-06-30T18:30:00.000Z', <!--y축 데이터-->
                'Ram': 359, <!--차트 데이터 + x축 데이터 -->
                'Laptops': 0, <!--차트 데이터 + x축 데이터 -->
                'Processor': 23 <!--차트 데이터 + x축 데이터 -->
            }, {
                'date': '2017-07-31T18:30:00.000Z',
                'Ram': 828,
                'Laptops': 1,
                'Processor': 30
            },
            {
                'date': '2017-08-31T18:30:00.000Z',
                'Ram': 788,
                'Laptops': 81,
                'Processor': 70
            }, {
                'date': '2017-09-30T18:30:00.000Z',
                'Ram': 503,
                'Laptops': 132,
                'Processor': 128
            }, {
                'date': '2017-10-31T18:30:00.000Z',
                'Ram': 844,
                'Laptops': 287,
                'Processor': 106
            }, {
                'date': '2017-11-30T18:30:00.000Z',
                'Ram': 1725,
                'Laptops': 114,
                'Processor': 131
            }, {
                'date': '2017-12-31T18:30:00.000Z',
                'Ram': 2761,
                'Laptops': 83,
                'Processor': 324
            },
            {
                'date': '2018-01-31T18:30:00.000Z',
                'Ram': 2120,
                'Laptops': 42,
                'Processor': 361
            }, {
                'date': '2018-02-28T18:30:00.000Z',
                'Ram': 1205,
                'Laptops': 32,
                'Processor': 172
            }, {
                'date': '2018-03-31T18:30:00.000Z',
                'Ram': 477,
                'Laptops': 48,
                'Processor': 57
            }, {
                'date': '2018-04-30T18:30:00.000Z',
                'Ram': 508,
                'Laptops': 49,
                'Processor': 37
            }
        ];
		<!--실제 데이터를 순회하면서 function(d)를 수행 -->
        salesData.forEach(function(d) {
            d = type(d);
        });
		<!--정해진 날짜 포맷에 맞추어 날짜 데이터를 가져온다. -->
        function type(d) {
            d.date = parseDate(new Date(d.date)); <!--d3 날짜 포맷에 맞추어 날짜 데이터를 생성한다. -->
            group.forEach(function(c) {
                d[c] = +d[c]; <!-- 날짜 데이터를 날짜 데이터 배열에 차례대로 추가한다. -->
            });
            return d; <!-- 모든 날짜 데이터를 배열에 추가한 후 배열을 리턴한다.-->
        }

		<!--stack layout을 구성한다.-->
        var layers = d3.stack() <!--d3 stacklayout 생성. offset 기본값은 0, 순서는 null이다. layout 객체가 리턴되고, 리턴된 layout 객체를 통해 다른 다양한 메소드 호출 가능. 또 setter 메소드를 집약적인 문장에 여러번 호출 가능 -->
            .keys(group) <!--stack layout의 key를 세팅한다. -->
            .offset(d3.stackOffsetDiverging) <!-- stack layout의 offset 를 세팅한다. -->
            (salesData); <!--판매 데이터 세팅한다. -->
		
		var svg = d3.select("svg");
		var margin = {
                top: 20,
                right: 30,
                bottom: 60,
                left: 60
            };
		var width = +svg.attr("width");
		var height = +svg.attr("height");
		var gX = null;
		var gY = null;
		var currentTransform = null;

		view = svg.append("g")
			.attr("class", "view");
		if (currentTransform) view.attr('transform', currentTransform);		
		
		var xScale = d3.scaleLinear()
		.domain([d3.min(layers, stackMin), d3.max(layers, stackMax)])
		.rangeRound([margin.left, width - margin.right]);
        
		var yScale = d3.scaleLinear()
			.domain([-height / 2, height / 2])
			.range([height, 0]);
		
		var xAxis = d3.axisBottom(xScale)
			.ticks(5)
			.tickSize(height)
			.tickPadding(8 - height);
		
		var yAxis = d3.axisRight(yScale)
			.ticks(10)
			.tickSize(width)
			.tickPadding(8 - width);
		gX = svg.append("g")
			.attr("class", "axis axis--x")
			.call(xAxis);
		gY = svg.append("g")
			.attr("class", "axis axis--y")
			.call(yAxis);
			
        var z = d3.scaleOrdinal(d3.schemeCategory10);

        var maing = svg.append("g")
            .selectAll("g")
            .data(layers);	
        var g = maing.enter().append("g")
			.attr("class", "layout")
            .attr("fill", function(d) {
                return z(d.key);
            });			
   var zoom = d3.zoom()
    .scaleExtent([0.5, 5])
    .translateExtent([
        [-width * 2, -height * 2],
        [width * 2, height * 2]
    ])
    .on("zoom", zoomed);
      
   function zoomed() {
    currentTransform = d3.event.transform;
    view.attr("transform", currentTransform);
    gX.call(xAxis.scale(d3.event.transform.rescaleX(xScale)));
    
}
		<!--stack layout의 최소값을 구한다.-->
        function stackMin(layers) {
            return d3.min(layers, function(d) {
                return d[0];
            });
        }
		<!--stack layout의 최대값을 구한다.-->
        function stackMax(layers) {
            return d3.max(layers, function(d) {
                return d[1];
            });
        }
  svg.call(zoom);
    </script>
</body>

</html>